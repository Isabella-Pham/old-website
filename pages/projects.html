<!doctype html>
<html lang = "en">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<head>
    <title>Projects</title>
</head>

<body id = "page-top" data-scroll-animation="true" style = "background-color:#CCCCCC">

  <link href="https://fonts.googleapis.com/css?family=Poppins" rel="stylesheet">
  <link href="../css/style.css" rel="stylesheet" type="text/css">
  <img src="../media/spirited away.jpg" id = "projects-background">

  <nav>
      <div class="logo">
          <h4>Isabella Pham  │ </h4>
      </div>
      <ul class = "nav-links">
        <li><a href="../index.html">HOME</a></li>
        <li><a href="contact.html">CONTACT</a></li>
        <li><a href="about.html">ABOUT</a></li>
        <li><a href="projects.html">PROJECTS</a></li>
        <li><a href="https://drive.google.com/open?id=1H1Hss-UwrhwXFdpIAFXyKDZRTUHofcRo" target="_blank">RESUME</a></li>
      </ul>
      <div class="burger">
          <div class="line1"></div>
          <div class="line2"></div>
          <div class="line3"></div>
      </div>
  </nav>

  <br/>
  <br/>
  <br/>
  <br/>

<div class = "projectList">
  <button class="accordion"><h1 style="color:black">Amazon</h1></button>
  <div class="panel">
    <br/><h2 style="color:black">Krypto</h2><br/>
    <p style="color:black">
        <b>Background:</b>
          Imagine you're an Amazon Music customer. For some reason, you keep hearing the song "Never Gonna Give You Up".
          You then furiously call customer support saying "If I hear the song 'Never Gonna Give You Up' one more damn time I am going to cancel my Amazon Music Subscription".
          Of course, Amazon does not want that. And so, developers will spend hours scouring through the data stored in AWS Redshift and writing involved SQL queries (which can be up to a couple hundred lines) to see what happened that caused you to get Rick Rolled several times.
          But alas! These SQL queries only return giant tables of text, and reading this text to find the problem is not easy.</br><br/>
        <b>Description:</b> Krypto is a data aggregation tool named after Krypto the Superdog. To solve the problem described, I created Krypto by programming a transfer pipeline from AWS Redshift to AWS Elasticsearch, as Elasticsearch comes with a configurable data visualizatoin tool known as Kibana.
          My pipeline would use lambdas that are triggered when new data is updated to AWS Redshift and would then transfer this data to AWS S3, as I use S3 as an intermediary between Elasticsearch and Redshift so that it could serve as an ingestion point for more data that is not stored in Redshift.
          When the data is injected into S3, another lambda then runs Python code to index the data into Elasticsearch.
          With the data in Elasticsearch, I configured Kibana to create visualizations such as graphs and charts to make it easier to spot trends and disrepencies in data.<br/><br/>
        <b>Programming Languages:</b> Python, SQL, Java<br/><br/>
        <b>Technologies:</b> AWS (Redshift, Lambda, S3, EC2, Cloudwatch, DynamoDB), ELK Stack (Elasticsearch, Logstash, Kibana), Security Protocols (LDAP Groups, AWS Cognito, OIDC Verification, IAM Roles) <br/><br/>
        <b>Other Learnings:</b> Mockito, JUnit Testing, Kinesis Streams, Kinesis Firehose, SNS/SQS<br/><br/>
        ___________________________________
    </p>
    <br/><br/><h2 style="color:black">Accesbility Resource Finder (ARF)</h2><br/>
    <p style="color:black">
        <b>Background:</b> Every year, Amazon hosts the AFE intern hackathon.
          In this hackathon, Amazon interns use Amazon technology to help nonprofit organizations.
          The organization my team decided to help was the Tyler Schrenk Foundation (TSF), an organization dedicated to helping quadriplegics become more independent.
          Tyler Schrenk, a quadriplegic himself, described many of his challenges how he was unable to find all the resources available to him.
          Thus, the Accesbility Resource Finder was born and became the winning Amazon intern hackathon project.<br/><br/>
        <b>Description:</b> The ARF is an Alexa skill programmed in Javascript within an AWS Lambda that is triggered once the skill is invoked.
        It is able to talk to individuals and find tools that suited their needs using a decision tree algorithm.
        For example if an individual wanted more control over their house by controlling the lights, the ARF can redirect them to an Alexa skill to help them do so.
        Additionally, when visiting the TSF’s website, I noticed that in order to receive assistance from the organization, an individual would have to fill out a form on their website.
        I wanted to create a way for quadriplegics to do this on their own, thus I added to the ARF the ability to surf websites by using JSSoup to scrape websites as well as the ability to fill out and submit forms using just voice controls. <br/><br/>
        <b>Programming Languages:</b> Javascript<br/><br/>
        <b>Technologies:</b> AWS (Lambda), Node.js, JSsoup, Alexa Skills Development SDK<br/><br/>
        <b>Other Learnings:</b> Being able to help someone with my computer science skills is an amazing experience<br/><br/>
    </p>
  </div>
  <button class="accordion"><h1 style="color:black">Goldman Sachs</h1></button>
  <div class="panel">
    <br/><h2 style="color:black">Eagleview</h2><br/>
      <p style="color:black">
          <b>Background:</b> RabbitMQ is an open-source software that manages messages in a secure manner.
            Goldman Sachs uses this software to create communication links between units such as clients, brokers, and exchanges in order for trades to be executed.
            In other words, when a trade is made a message is sent from the client using RabbitMQ to all units needed to execute that trade.<br/><br/>
          <b>Description:</b> Eagleview is an analytical web app that creates a model of the RabbitMQ communications.
            It models the communications by creating a graph where each node is a different unit (client, brokerage, or exchange) and each edge represents a communication between them.
            When clicking on a specific node, a side panel appears with additional information about it and buttons that redirect to other sources of data about the node such as MongoDB, Pulse, or Grafana.
            The graph and its related data is not only used to visualize communications, but to create a machine learning model to perform predictive analysis and predict problems before they happen.
            By doing so, we can address these problems prematurely to decrease latency and ensure that transactions happen fast and smoothly.
            This time difference could ideally help save millions of dollars that may have been lost if trades were not executed fast enough. <br/><br/>
          <b>Programming Languages:</b> Python, Javascript, HTML/CSS, PromQL <br/><br/>
          <b>Technologies:</b> Tensorflow, Kubernetes, Node.js, MongoDB, Pulse (Goldman Sachs' proprietary time series database), Prometheus/Grafana, RabbitMQ, React, D3.js<br/><br/>
          <b>Other Learnings:</b> Gitlab, Jira, Python Unit Testing, Slang (Goldman Sachs' proprietary programming language)<br/><br/>
      </p>
  </div>
  <button class="accordion"><h1 style="color:black">Colgate-Palmolive</h1></button>
  <div class="panel">
    <br/><h2 style="color:black">Capillaroscopy</h2><br/>
      <p style="color:black">
          <b>Background:</b> Capillaroscopy is a diagnostic technique used to reveal capillaries.
            The initial images taken during capillaroscopy however can be hard to analyze as the capillaries may not be easily identifiable.
            Thus, one can create an algorithm to reveal capillaries in great detail.
            Then, they can analyze factors such as blood flow and look for any anomalies such as broken capillaries which could be used to identify health issues such as gingivitis.<br/><br/>
          <b>Description:</b> I created an image enhancement software in MATLAB to enhance the capillaries in capillaroscopic images.
            To define the capillaries, I used several filters such as an alpha trimmed mean filter (used to remove non-Gaussian noise from an image, essentially it uses mathematical formulas to look for pixel deviations from other pixels that make the image appear "fuzzy") and histogram equalization (used to enhance the contrast of the image).
            Additionally, I created my own algorithm to trace the capillaries in an image to make them further stand out and calculated the diameter of these capillaries.
            Gingivitis causes blood vessel inflammation, thus we can identify it by determining if the diameter of the capillaries are greater than they should be.<br/><br/>
          <b>Programming Languages:</b> Matlab<br/><br/>
          <b>Technologies:</b> MATLAB image filters<br/><br/>
          <b>Other Learnings:</b> Capillaroscopy and the biology behind it<br/><br/>
          ___________________________________
      </p>
    <br/><h2 style="color:black">Quantitative Light Induced Flourescence (QLF)</h2><br/>
      <p style="color:black">
          <b>Background: </b> Quantitative Light Induced Fluorescence (QLF) is a diagnostic technique used to reveal carious (decaying) spots known as caries on teeth by using their fluorescence (radiation, hence why teeth are bright).
            Caries have a lower fluorescence than normal enamel, making them easy to identify using QLF. The more effective a Colgate product is at eliminating caries, the greater the overall fluorescence of the teeth will be.
            In studies to analyze the effectiveness of Colgate products, QLF is used by taking photos of subjects teeth over a period of time (with all photos centered with controlled lighting).
            If there is an increase in fluorescence, then it is possible to conclude that the product is effective.
            Normally, analyzing these photos and quantifying their fluorescence can take weeks as there are many subjects to go through.
            Thus, I created code to automate this process of quantifying light induced flourescence. <br/><br/>
          <b>Description:</b> I created a light induced flourescence quantifier in MATLAB by first programming image segmentation software.
            This involved isolating everything that wasn't teeth by creating customized masks that analyzed the coloration of a pixel to determine whether or not it was teeth.
            The masked is then used to overlay each image so that only the teeth are shown.
            From there, a special formula that uses the RGB values of the image is applied to calculate the fluorescence of the teeth.<br/><br/>
          <b>Programming Languages:</b> Matlab<br/><br/>
          <b>Technologies:</b> MATLAB Image masking<br/><br/>
          <b>Other Learnings:</b> Quantitative Light Induced Fluorescence and the biology behind it<br/><br/>
          ___________________________________
      </p>
    </li>
    <br/><h2 style="color:black">Infrared Spectroscopy</h2><br/>
      <p style="color:black">
          <b>Background:</b> Infrared spectroscopy is a diagnostic technique that utilizes the interactions between infrared radiation and objects to analyze their transmittance and calculate their reflectance.
            The more reflective teeth are, the whiter they are (as white surfaces are the most reflective compared to other colors).
            The more effective a Colgate product is at whitening teeth, the greater the overall reflectance of the teeth will be.
            Thus, in studies to analyze the effectiveness of Colgate products, infrared spectroscopy is used by collecting LAB color values with a spectrometer.
            LAB color values are essentially the coordinates of a color in the LAB color space.
            Each letter stands for the following:<br/>
              </t>- L: Lightness<br/>
              </t>- a: Red/Green Value (more positive is more red, more negative is more green)<br/>
              </t>- b: Blue/Yellow Value (more positive is more yellow, more negative is more blue)<br/>
            LAB values are not the reflectance of the teeth, though the reflectance can be derived from it.
            Traditionally, reflectance is derived with manual labor and many calculations.
            However, I created software to automate this process.<br/><br/>
          <b>Description:</b> Coming soon...<br/><br/>
          <b>Programming Languages:</b> Matlab<br/><br/>
          <b>Technologies:</b> Spectrometer<br/><br/>
          <b>Other Learnings:</b> Infrared Spectroscopy and the physics/biology behind it<br/><br/>
      </p>
  </div>
  <button class="accordion"><h1 style="color:black">SEQAM Lab</h1></button>
  <div class="panel">
    <br/><h2 style="color:black">Nutrition Data Mapping</h2><br/>
      <p style="color:black">
          <b>Background:</b> Nutritional deficiencies, overweight, and obesity are health problems that have become increasingly concerning in the United States.
            SEQAM Lab and Samsung research are currently working together on developing machine learning software that can scan images and detect the type of food it is, its ingredients and their amounts, as well as nutritional information about the dish itself.
            With this software, SEQAM Lab aims to create a phone app that could determine the food in an image and its nutritional information as individuals like to take pictures of their food. <br/><br/>
          <b>Description:</b> In order to provide nutritional information on dishes, we need enriched data of the nutritional information of many different ingredients.
            Thus, I created a Python program to query the USDA database through their API.
            First, SEQAM Lab created a web crawler to collect recipes from the Internet.
            Then, a list of ingredients was created from all of these recipes.
            Each ingredient was then queried through the USDA JSON API which returned a list of all relevant results.
            To find the most relevant result to the ingredient, natural language processing through the NLTK library was used to identify different parts of speech.
            Then, the Matplotlib library was used to determine the entropy distribution of queries to qualitatively determine a proper entropy cutoff to ensure the acucracy of results.
            If results were not accurate enough, the ingredient was then queried through the Nutritionix JSON API.
            This research was then presented to Rutgers students, faculty, and associates at the Rutgers' Research Symposium.<br/><br/>
          <b>Programming Languages:</b> Python<br/><br/>
          <b>Technologies:</b> NLTK, Matplotlib, USDA JSON API, Nutritionix JSON API<br/><br/>
          <b>Other Learnings:</b> Writing a research paper, presenting research <br/><br/>
          ___________________________________
      </p>
    <br/><h2 style="color:black">Recipe Annotator</h2><br/>
      <p style="color:black">
          <b>Background:</b> Same as above <br/><br/>
          <b>Description:</b> In order to train a machine learning model to identify foods and its ingredients using the recipes collected as training data, the computer must first understand recipes and its components such as ingredients, cooking time, amounts, cooking utensils, etc...
          Thus, I created a recipe annotation tool based on the open note software Doccano that allows individuals to highlight a word and label what it is.
          This research was then presented to government officials at the NJ State House through the state's Government Scholars program.<br/><br/>
          <b>Programming Languages:</b> Python, HTML/CSS, Javascript <br/><br/>
          <b>Technologies:</b> Heroku, Docker, React.js, Vue.js, Node.js<br/><br/>
          <b>Other Learnings:</b> Building on top of open source software <br/><br/>
      </p>
  </div>
  <button class="accordion"><h1 style="color:black">DataDog</h1></button>
  <div class="panel">
    <br/><p style="color:black">Coming soon on 8/31...</p><br/>
  </div>
  <button class="accordion"><h1 style="color:black">School</h1></button>
  <div class="panel">
    <br/><h2 style="color:black"> CS336: Train Booking System</h2><br/>
      <p style="color:black">
          <b>Description:</b> Train Booking System is a website where one can search train routes stored in an AWS RDS database, create an account to make a reservation, login to modify reservations, and is configured to work with admin and employee privileges as well, allowing employees to answer customer tickets and admins to receive sales reports and customer employee information.
          It was written for my Principles of Information and Data Management (CS336) class at Rutgers University to display proficiency in database management, AWS, and SQL. <br/><br/>
          <b>Programming Languages:</b> SQL, Java, HTML <br/><br/>
          <b>Technologies:</b> AWS (RDS, EC2), Java Server Pages (JSP), Tomcat <br/><br/>
          ___________________________________
      </p>
    <br/><h2 style="color:black"> CS214: Where's the File (WTF)?</h2><br/>
      <p style="color:black">
          <b>Description:</b> "Where's the file?" (abbreviated WTF) is a version control system written in C that allows up to 10 clients modify a repository in a remote server containing code projects.
          It was written for my Systems Programming (CS214) class at Rutgers University to display proficiency in socket programming, multithreading, and file I/O. <br/><br/>
          <b>Programming Languages:</b> C <br/><br/>
          <b>Technologies:</b> Sockets, Multithreading, file I/O<br/><br/>
          ___________________________________
      </p>
    <br/><h2 style="color:black"> CS111: Song App</h2><br/>
      <p style="color:black">
          <b>Description:</b> Song App is a Java application that stores song data locally in Song objects.
          These song objects contain an attribute for song name, release year, rating, and an array of writers.
          Song App allows individuals to search, update, or add songs
          It was written for my Introduction to Computer Science (CS111) class at Rutgers University to display proficiency in Java programming, understanding of Java classes, and system I/O.<br/><br/>
          <b>Programming Languages:</b> Java <br/><br/>
          <b>Technologies:</b> none (just pure Java) <br/><br/>
      </p>
  </div>
  <button class="accordion"><h1 style="color:black">Flight and Space Program</h1></button>
  <div class="panel">
    <br/><h2 style="color:black">Near Space Satellite</h2><br/>
      <p style="color:black">
          <b>Background:</b> The Flight and Space Program is a near-space research experience featuring mentors from renowned corporations such as T-Mobile and Microsoft.
          With the supervision of instructors, members of the program created their own CubeSats, launching these CubeSats into the atmosphere where they reached altitutdes of 120,000 feet and monitored atmospheric conditions.
          Under the guidance of Microsoft's Principle Escalation Officer Dan Ruder, I spent 4 years in the Flight and Space Program from middle to high school creating several CubeSats. <br/><br/>
          <b>Description:</b>  For each year in the program, I began my CubeSat by developing a new, self-directed mission plan to construct a CubeSat for.
            Utilized computer aided design through Autodesk Inventor to design a satellite and 3D print its parts
            Constructed flight controllers and sensors, soldering an Arduino UNO board
            Programmed a Geiger counter and digital light, pressure, and oxygen sensors in C++ <br/><br/>
          <b>Programming Languages:</b> C++, PICAXE <br/><br/>
          <b>Technologies:</b> Arduino <br/><br/>
          <b>Other Learnings:</b> Autodesk Inventor, Soldering, Circuits, Metal/Wood-working (bandsaw, drill press, routing table, engraver, planer, tablesaw) <br/><br/>
      </p>
  </div>
</div>

  <script>
    var acc = document.getElementsByClassName("accordion");
    var i;

    for (i = 0; i < acc.length; i++) {
      acc[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var panel = this.nextElementSibling;
        if (panel.style.maxHeight) {
          panel.style.maxHeight = null;
        } else {
          panel.style.maxHeight = panel.scrollHeight + "px";
        }
      });
    }
  </script>
  <script src="../app.js"></script>

</body>
</html>
